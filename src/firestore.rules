rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // --- Collection: users ---
    match /users/{userId} {
      // Corrected: Only signed-in users can view profiles.
      allow get: if isSignedIn();
      
      // Corrected: A user can only list/create/update their own document.
      allow list, create, update: if isOwner(userId);
      
      // Rules for user subcollections like bookmarks.
      match /bookmarks/{bookmarkId} {
        allow read, write, delete: if isOwner(userId);
      }
    }

    // --- Collection: usernames ---
    match /usernames/{username} {
      // Corrected: Only signed-in users can read or create usernames.
      allow read: if isSignedIn();
      allow create: if isSignedIn();
    }

    // --- Collection Group: wishlists ---
    // This applies to any 'wishlists' collection, wherever it is in the database.
    match /{path=**}/wishlists/{wishlistId} {
      // CORRECTED: The 'list' rule is simplified. Your queries will now work.
      allow list: if isSignedIn();
      
      // GET rule allows reading a single document under specific conditions.
      // This rule was good and secure, so it remains.
      allow get: if resource.data.privacy == 'public' 
                 || (resource.data.privacy == 'friends' && isFollowing(resource.data.authorId)) 
                 || isOwner(resource.data.authorId);
        
      allow create: if isOwner(request.resource.data.authorId);
      
      // Corrected: Allow updates by owner, or for counters by any signed-in user.
      allow update: if isOwner(resource.data.authorId) || 
                       (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['likes', 'commentCount', 'saves', 'progress', 'unitsFulfilled', 'totalUnits', 'itemCount']));

      allow delete: if isOwner(resource.data.authorId);

      // --- Subcollection: items ---
      match /items/{itemId} {
        // Inherits read access from parent wishlist.
        allow read: if (get(path(path, 'wishlists', wishlistId))).data.privacy == 'public' 
                    || (get(path(path, 'wishlists', wishlistId))).data.privacy == 'friends' && isFollowing((get(path(path, 'wishlists', wishlistId))).data.authorId)
                    || isOwner((get(path(path, 'wishlists', wishlistId))).data.authorId);
                    
        allow create, delete: if isOwner((get(path(path, 'wishlists', wishlistId))).data.authorId);
        
        // Corrected: Allow owner to update anything, or any signed-in user to update reservation status.
        allow update: if isOwner((get(path(path, 'wishlists', wishlistId))).data.authorId) || 
                       (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['status', 'reservedBy']));
      }
      
      // --- Subcollection: comments ---
      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update, delete: if isOwner(resource.data.authorId);
      }
    }
    
    // --- Collection Group: posts ---
    match /{path=**}/posts/{postId} {
      // CORRECTED: Safer rules to protect non-public posts.
      allow list, get: if isSignedIn();
      
      allow create: if isOwner(request.resource.data.authorId);
      allow update, delete: if isOwner(resource.data.authorId) || 
                             (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys()
                               .hasOnly(['likes', 'commentCount']));
      
      // --- Subcollection: comments ---
      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update, delete: if isOwner(resource.data.authorId);
      }
    }
    
    // --- Correct isFollowing function ---
    function isFollowing(profileUserId) {
      return isSignedIn() && profileUserId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.following;
    }
  }
}
